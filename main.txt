from fastapi import FastAPI, Query, HTTPException, UploadFile, File
from typing import List, Optional
import json

# Celery ê´€ë ¨ importë¥¼ ë¨¼ì € í•˜ì—¬ ìˆœí™˜ import ë°©ì§€
from background.celery import celery_app
from background.task.test_tasks import (
    add, multiply, finalize, show_request_info,
    process_user_batch, send_email_campaign, generate_report_chunk,
    start_large_user_processing, start_bulk_email_campaign
)
from background.task.document_tasks import process_document, process_document_batch
from celery import chain, group, chord
from celery.result import GroupResult

app = FastAPI(title="Celery Test Harder", description="ë¶„ì‚° ì‘ì—… ì²˜ë¦¬ ì‹œìŠ¤í…œ")

# ë‹¤ë¥¸ ì•± ë¼ìš°í„°ëŠ” celery ì´ˆê¸°í™” í›„ì— import
from sample_app import sample_router

routers = [sample_router]

for router in routers:
    app.include_router(router)

from pydantic import BaseModel

class AddRequest(BaseModel):
    x : int
    y: int

@app.post("/add")
async def celery_add(req: AddRequest):
    task = add.delay(req.x, req.y)
    return {"task_id": task.id, "type": "single"}

@app.post("/chain")
async def run_chain(req: AddRequest):
    job = chain(
        add.s(req.x, req.y),       # add(2, 3) â†’ 5
        multiply.s(10),            # multiply(5, 10) â†’ 50
        finalize.s()               # finalize(50)
    )
    result = job.apply_async()
    return {"task_id": result.id, "type": "chain"}

@app.post("/group")
async def run_group(req: AddRequest):
    job = group(
        add.s(req.x, req.y),       # ë³‘ë ¬ 1
        multiply.s(req.x, req.y)   # ë³‘ë ¬ 2
    )
    result = job.apply_async()
    
    # ê°œë³„ ì‘ì—… IDë“¤ì„ ì¶”ì¶œ
    task_ids = [task.id for task in result.results]
    
    return {
        "group_id": result.id, 
        "type": "group",
        "task_ids": task_ids  # ê°œë³„ ì‘ì—… IDë“¤ í¬í•¨
    }

@app.post("/chord")
async def run_chord(req: AddRequest):
    header = group(
        add.s(req.x, req.y),
        multiply.s(req.x, req.y)
    )
    callback = finalize.s()
    job = chord(header)(callback)
    return {"chord_id": job.id, "type": "chord"}


@app.get("/result/{task_id}")
async def get_single_result(task_id: str):
    """ë‹¨ì¼ ì‘ì—… ê²°ê³¼ ì¡°íšŒ"""
    result = celery_app.AsyncResult(task_id)
    return {
        "task_id": task_id,
        "type": "single",
        "status": result.status,
        "result": result.result if result.ready() else None,
        "ready": result.ready(),
        "successful": result.successful() if result.ready() else False,
        "failed": result.failed() if result.ready() else False
    }


@app.get("/chain-result/{task_id}")
async def get_chain_result(task_id: str):
    """Chain ì‘ì—… ê²°ê³¼ ì¡°íšŒ"""
    result = celery_app.AsyncResult(task_id)
    return {
        "task_id": task_id,
        "type": "chain",
        "status": result.status,
        "result": result.result if result.ready() else None,
        "ready": result.ready(),
        "successful": result.successful() if result.ready() else False,
        "failed": result.failed() if result.ready() else False,
        "info": "Chainì˜ ìµœì¢… ê²°ê³¼ì…ë‹ˆë‹¤"
    }


@app.get("/group-result/{group_id}")
async def get_group_result(group_id: str, task_ids: Optional[str] = Query(None, description="Comma-separated task IDs")):
    """Group ì „ìš© ê²°ê³¼ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸"""
    try:
        # task_idsê°€ ì œê³µëœ ê²½ìš° ì§ì ‘ ì¡°íšŒ
        if task_ids:
            task_id_list = task_ids.split(",")
            results = []
            all_completed = True
            successful_count = 0
            
            for task_id in task_id_list:
                task_result = celery_app.AsyncResult(task_id)
                result_data = {
                    "task_id": task_id,
                    "status": task_result.status,
                    "result": task_result.result if task_result.ready() else None,
                    "ready": task_result.ready()
                }
                results.append(result_data)
                
                if not task_result.ready():
                    all_completed = False
                elif task_result.successful():
                    successful_count += 1
            
            return {
                "group_id": group_id,
                "type": "group",
                "all_completed": all_completed,
                "successful": successful_count == len(task_id_list) and all_completed,
                "failed": any(r["status"] == "FAILURE" for r in results),
                "total_tasks": len(task_id_list),
                "completed_tasks": sum(1 for r in results if r["ready"]),
                "results": results,
                "method": "direct_task_query"
            }
        
        # ë¨¼ì € GroupResultë¡œ ì‹œë„
        try:
            group_result = GroupResult.restore(group_id, app=celery_app)
            if group_result is not None and hasattr(group_result, 'results'):
                results = []
                for task_result in group_result.results:
                    results.append({
                        "task_id": task_result.id,
                        "status": task_result.status,
                        "result": task_result.result if task_result.ready() else None,
                        "ready": task_result.ready()
                    })
                
                return {
                    "group_id": group_id,
                    "type": "group",
                    "all_completed": group_result.ready(),
                    "successful": group_result.successful() if group_result.ready() else False,
                    "failed": group_result.failed() if group_result.ready() else False,
                    "total_tasks": len(results),
                    "completed_tasks": sum(1 for r in results if r["ready"]),
                    "results": results,
                    "method": "group_result_restore"
                }
        except Exception as e:
            print(f"GroupResult.restore failed: {e}")
        
        # GroupResultê°€ ì‘ë™í•˜ì§€ ì•Šìœ¼ë©´ AsyncResultë¡œ ì‹œë„
        async_result = celery_app.AsyncResult(group_id)
        
        if async_result.ready() and isinstance(async_result.result, list):
            # Group ê²°ê³¼ê°€ ì¤€ë¹„ë˜ì—ˆê³  ê²°ê³¼ê°€ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš°
            results = []
            for i, result_value in enumerate(async_result.result):
                results.append({
                    "task_id": f"{group_id}_task_{i}",
                    "status": "SUCCESS",
                    "result": result_value,
                    "ready": True
                })
            
            return {
                "group_id": group_id,
                "type": "group",
                "all_completed": True,
                "successful": True,
                "failed": False,
                "total_tasks": len(results),
                "completed_tasks": len(results),
                "results": results,
                "method": "async_result_list"
            }
        else:
            # ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì€ ê²½ìš°
            return {
                "group_id": group_id,
                "type": "group",
                "status": async_result.status,
                "all_completed": False,
                "successful": False,
                "failed": False,
                "total_tasks": 0,
                "completed_tasks": 0,
                "results": [],
                "info": "Group ì‘ì—…ì´ ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
                "method": "async_result_fallback"
            }
        
    except Exception as e:
        return {"error": f"Failed to get group result: {str(e)}"}


@app.get("/chord-result/{chord_id}")
async def get_chord_result(chord_id: str):
    """Chord ì‘ì—… ê²°ê³¼ ì¡°íšŒ"""
    try:
        # ChordëŠ” ì½œë°± ê²°ê³¼ë¥¼ AsyncResultë¡œ ì¡°íšŒ
        result = celery_app.AsyncResult(chord_id)
        
        return {
            "chord_id": chord_id,
            "type": "chord",
            "status": result.status,
            "result": result.result if result.ready() else None,
            "ready": result.ready(),
            "successful": result.successful() if result.ready() else False,
            "failed": result.failed() if result.ready() else False,
            "info": "Chordì˜ ì½œë°± ê²°ê³¼ì…ë‹ˆë‹¤ (ê·¸ë£¹ ì‘ì—…ë“¤ì´ ëª¨ë‘ ì™„ë£Œëœ í›„ì˜ ìµœì¢… ê²°ê³¼)"
        }
        
    except Exception as e:
        return {"error": f"Failed to get chord result: {str(e)}"}


@app.post("/test-request-info")
async def test_request_info(message: str = "Hello World"):
    """self.request ì •ë³´ í…ŒìŠ¤íŠ¸ìš© ì—”ë“œí¬ì¸íŠ¸"""
    task = show_request_info.delay(message)
    return {
        "message": "Request info test started",
        "task_id": task.id,
        "check_result": f"/result/{task.id}"
    }

# ìƒˆë¡œìš´ Request ëª¨ë¸ë“¤
class UserBatchRequest(BaseModel):
    user_ids: List[int]

class EmailCampaignRequest(BaseModel):
    email_list: List[str]
    template_id: str

class ReportRequest(BaseModel):
    date_range: dict
    chunk_id: int

class BulkUserRequest(BaseModel):
    all_user_ids: List[int]

class BulkEmailRequest(BaseModel):
    all_emails: List[str]
    template_id: str

class DocumentRequest(BaseModel):
    file_path: str
    operation: str = "analyze"

class DocumentBatchRequest(BaseModel):
    file_paths: List[str]

# ===== ìƒˆë¡œìš´ ì‹¤ë¬´ ì ì • í¬ê¸° Task ì—”ë“œí¬ì¸íŠ¸ë“¤ =====

@app.post("/process-user-batch")
async def process_user_batch_endpoint(request: UserBatchRequest):
    """âœ… ì ì • í¬ê¸°: ì‚¬ìš©ì ë°°ì¹˜ ì²˜ë¦¬ (100ëª… ì´í•˜, 2-3ë¶„ ì†Œìš”)"""
    if len(request.user_ids) > 100:
        raise HTTPException(status_code=400, detail="ë°°ì¹˜ í¬ê¸°ëŠ” 100ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    task = process_user_batch.delay(request.user_ids)
    return {
        "task_id": task.id,
        "message": f"{len(request.user_ids)}ëª… ì‚¬ìš©ì ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘",
        "estimated_time": "2-3ë¶„",
        "status": "PENDING"
    }

@app.post("/send-email-campaign")
async def send_email_campaign_endpoint(request: EmailCampaignRequest):
    """âœ… ì ì • í¬ê¸°: ì´ë©”ì¼ ìº í˜ì¸ ë°œì†¡ (200ê°œ ì´í•˜, 3-5ë¶„ ì†Œìš”)"""
    if len(request.email_list) > 200:
        raise HTTPException(status_code=400, detail="ì´ë©”ì¼ ë°°ì¹˜ í¬ê¸°ëŠ” 200ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    task = send_email_campaign.delay(request.email_list, request.template_id)
    return {
        "task_id": task.id,
        "message": f"{len(request.email_list)}ê°œ ì´ë©”ì¼ ë°œì†¡ ì‹œì‘",
        "template_id": request.template_id,
        "estimated_time": "3-5ë¶„",
        "status": "PENDING"
    }

@app.post("/generate-report-chunk")
async def generate_report_chunk_endpoint(request: ReportRequest):
    """âœ… ì ì • í¬ê¸°: ë¦¬í¬íŠ¸ ì²­í¬ ìƒì„± (3-4ë¶„ ì†Œìš”)"""
    task = generate_report_chunk.delay(request.date_range, request.chunk_id)
    return {
        "task_id": task.id,
        "message": f"ë¦¬í¬íŠ¸ ì²­í¬ {request.chunk_id} ìƒì„± ì‹œì‘",
        "date_range": request.date_range,
        "estimated_time": "3-4ë¶„",
        "status": "PENDING"
    }

@app.post("/process-document")
async def process_document_endpoint(request: DocumentRequest):
    """âœ… ì ì • í¬ê¸°: ë‹¨ì¼ ë¬¸ì„œ ì²˜ë¦¬ (3-5ë¶„ ì†Œìš”)"""
    task = process_document.delay(request.file_path, request.operation)
    return {
        "task_id": task.id,
        "message": f"ë¬¸ì„œ ì²˜ë¦¬ ì‹œì‘: {request.file_path}",
        "operation": request.operation,
        "estimated_time": "3-5ë¶„",
        "status": "PENDING"
    }

@app.post("/process-document-batch")
async def process_document_batch_endpoint(request: DocumentBatchRequest):
    """âœ… ì ì • í¬ê¸°: ë¬¸ì„œ ë°°ì¹˜ ì²˜ë¦¬ (ìµœëŒ€ 10ê°œ, 2-3ë¶„ ì†Œìš”)"""
    if len(request.file_paths) > 10:
        raise HTTPException(status_code=400, detail="ë°°ì¹˜ í¬ê¸°ëŠ” 10ê°œ íŒŒì¼ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    task = process_document_batch.delay(request.file_paths)
    return {
        "task_id": task.id,
        "message": f"{len(request.file_paths)}ê°œ ë¬¸ì„œ ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘",
        "estimated_time": "2-3ë¶„",
        "status": "PENDING"
    }

# ===== ëŒ€ìš©ëŸ‰ ì‘ì—… ë¶„í•  ì²˜ë¦¬ ì—”ë“œí¬ì¸íŠ¸ë“¤ =====

@app.post("/bulk-user-processing")
async def bulk_user_processing_endpoint(request: BulkUserRequest):
    """ëŒ€ìš©ëŸ‰ ì‚¬ìš©ì ì²˜ë¦¬ë¥¼ ì ì ˆí•œ í¬ê¸°ë¡œ ë¶„í• í•˜ì—¬ ì‹¤í–‰"""
    total_users = len(request.all_user_ids)
    batch_size = 100
    expected_batches = (total_users + batch_size - 1) // batch_size  # ì˜¬ë¦¼ ê³„ì‚°
    
    task_ids = start_large_user_processing(request.all_user_ids)
    
    return {
        "message": f"ì´ {total_users}ëª…ì„ {expected_batches}ê°œ ë°°ì¹˜ë¡œ ë¶„í• í•˜ì—¬ ì²˜ë¦¬ ì‹œì‘",
        "total_users": total_users,
        "batch_size": batch_size,
        "batch_count": expected_batches,
        "task_ids": task_ids,
        "estimated_total_time": f"{expected_batches * 3}ë¶„ (ë³‘ë ¬ ì²˜ë¦¬ ì‹œ ìµœëŒ€ 3ë¶„)"
    }

@app.post("/bulk-email-campaign")
async def bulk_email_campaign_endpoint(request: BulkEmailRequest):
    """ëŒ€ìš©ëŸ‰ ì´ë©”ì¼ì„ ì ì ˆí•œ í¬ê¸°ë¡œ ë¶„í• í•˜ì—¬ ë°œì†¡"""
    total_emails = len(request.all_emails)
    batch_size = 200
    expected_batches = (total_emails + batch_size - 1) // batch_size
    
    task_ids = start_bulk_email_campaign(request.all_emails, request.template_id)
    
    return {
        "message": f"ì´ {total_emails}ê°œ ì´ë©”ì¼ì„ {expected_batches}ê°œ ë°°ì¹˜ë¡œ ë¶„í• í•˜ì—¬ ë°œì†¡ ì‹œì‘",
        "total_emails": total_emails,
        "batch_size": batch_size,
        "batch_count": expected_batches,
        "template_id": request.template_id,
        "task_ids": task_ids,
        "estimated_total_time": f"{expected_batches * 5}ë¶„ (ë³‘ë ¬ ì²˜ë¦¬ ì‹œ ìµœëŒ€ 5ë¶„)"
    }

# ===== ë°°ì¹˜ ìƒíƒœ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸ =====

@app.get("/batch-status/{task_ids}")
async def get_batch_status(task_ids: str):
    """ì—¬ëŸ¬ ë°°ì¹˜ ì‘ì—…ì˜ ìƒíƒœë¥¼ í•œë²ˆì— ì¡°íšŒ"""
    task_id_list = task_ids.split(",")
    batch_status = []
    
    for task_id in task_id_list:
        try:
            result = celery_app.AsyncResult(task_id.strip())
            
            batch_status.append({
                "task_id": task_id.strip(),
                "status": result.status,
                "result": result.result if result.ready() else None,
                "ready": result.ready()
            })
        except Exception as e:
            batch_status.append({
                "task_id": task_id.strip(),
                "status": "ERROR",
                "error": str(e),
                "ready": False
            })
    
    # ì „ì²´ ë°°ì¹˜ ìƒíƒœ ìš”ì•½
    total_tasks = len(batch_status)
    completed_tasks = sum(1 for task in batch_status if task.get("ready", False))
    pending_tasks = total_tasks - completed_tasks
    
    return {
        "batch_summary": {
            "total_tasks": total_tasks,
            "completed_tasks": completed_tasks,
            "pending_tasks": pending_tasks,
            "completion_rate": f"{(completed_tasks / total_tasks * 100):.1f}%" if total_tasks > 0 else "0%"
        },
        "task_details": batch_status
    }

# ===== í—¬ìŠ¤ì²´í¬ ë° ì •ë³´ ì—”ë“œí¬ì¸íŠ¸ =====

@app.get("/")
async def root():
    """API ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸"""
    return {
        "message": "ğŸš€ Celery Test Harder API",
        "status": "active",
        "docs": "/docs",
        "endpoints": {
            "basic_tasks": ["/add", "/chain", "/group", "/chord"],
            "results": ["/result/{task_id}", "/chain-result/{task_id}", "/group-result/{group_id}", "/chord-result/{chord_id}"],
            "advanced_tasks": ["/process-user-batch", "/send-email-campaign", "/generate-report-chunk", "/process-document", "/process-document-batch"],
            "bulk_operations": ["/bulk-user-processing", "/bulk-email-campaign"],
            "monitoring": ["/batch-status/{task_ids}", "/test-request-info"]
        }
    }

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸"""
    try:
        # Celery ì—°ê²° ìƒíƒœ í™•ì¸
        inspect = celery_app.control.inspect()
        workers = inspect.active()
        
        return {
            "status": "healthy",
            "celery_workers": len(workers) if workers else 0,
            "redis_connection": "connected"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e)
        }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
